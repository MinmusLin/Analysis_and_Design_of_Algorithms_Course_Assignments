# Review Notes

## 01 引言

**算法的定义**：在有限时间内，对问题求解的一个清晰的指令序列。算法的每个输入确定了该算法求解问题的一个实例。

**算法的特点**：输入（ $≥0$ ）、输出（ $≥1$ ）、确定性、有穷性、可行性

**相关算法**：

* 欧几里得算法
* 连续整数检测算法
* 质因数分解
* 埃拉托色尼筛选法

## 02 算法效率分析基础

**算法效率分析框架**：

* 衡量输入大小
* 衡量运行时间的单位
* （算法效率函数的）增长结束
* 最差情况、最佳情况、平均情况

**基本操作**：对总运行时间影响最大的操作。

* 排序：键的比较
* 四则运算：乘除法

效率分析框架忽略了乘法常数，重点关注 $C(n)$ 的增长阶数。

最优情况并不是指规模最小的输入，而是使算法运行得最快的、规模为 $n$ 的输入。

**平均效率**：

$$
T_{\text{avg}}(N) = \sum_{I \in D_N} P(I)T(N, I) = \sum_{I \in D_N} P(I) \sum_{i=1}^{k} t_{i}e_{i}(N, I)
$$

如果当 $n→∞$ 时， $T(n)→∞$ ， $(T(n)-t(n))/T(n)→0$ ，则称 $t(n)$ 为 $T(n)$ （ $n→∞$ ）的渐进状态， $t(n)$ 为该算法（ $n→∞$ ）的渐进复杂度。

**用于比较算法基本运算次数增长顺序的三种符号**：

* $O(g(n))$ ：存在某个正常数和某个非负整数，使得对于所有 $n \geq n_0$ 有 $t(n) \leq c \cdot g(n)$ （低阶或同阶增长）

  ![](assets/2024-06-23_11-55-12.png)

* $Ω(g(n))$ ：存在某个正常数和某个非负整数，使得对于所有 $n \geq n_0$ 有 $t(n) \geq c \cdot g(n)$ （高阶或同阶增长）

  ![](assets/2024-06-23_11-55-51.png)

* $Θ(g(n))$ ：存在某两个正常数和某个非负整数，使得对于所有 $n \geq n_0$ 有 $c_2 \cdot g(n) \leq t(n) \leq c_1 \cdot g(n)$ （同阶增长）

  ![](assets/2024-06-23_11-57-24.png)

![](assets/2024-06-23_11-57-41.png)

**其他用于比较算法基本运算次数增长顺序的符号**：

* $o(g(n))$ ：存在某个正常数和某个非负整数，使得对于所有 $n \geq n_0$ 有 $t(n) < c \cdot g(n)$ （低阶增长）
* $ω(g(n))$ ：存在某个正常数和某个非负整数，使得对于所有 $n \geq n_0$ 有 $t(n) > c \cdot g(n)$ （高阶增长）

**渐近增长阶数特性（也适用于 $Ω$ 符号和 $Θ$ 符号）**：

* 反身性： $f(n)∈O(f(n))$
* 传递性： $f(n)∈O(g(n)), g(n)∈O(h(n)) ⇒ f(n)∈O(h(n))$
* 互对称性： $f(n)∈O(g(n)) ⇔ g(n)∈Ω(f(n))$
* 对称性： $f(n)∈Θ(g(n)) ⇔ g(n)∈Θ(f(n))$
* 加法计算： $O(g_1(n))+O(g_2(n))=O(g_1(n)+g_2(n))$
* 乘法计算： $O(g_1(n)) \times O(g_2(n))=O(g_1(n) \times g_2(n))$
* 忽略常数： $O(cf(n))=O(f(n))$

对于由两个连续执行的部分组成的算法，算法的整体效率将由增长阶数较大的部分决定。

$$
\lim_{n \to \infty} \frac{T(n)}{g(n)} = 
\begin{cases} 
0, & T(n) \text{的增长阶数} < g(n) \text{的增长阶数（} O \text{符号）} \\
c > 0, & T(n) \text{的增长阶数} = g(n) \text{的增长阶数（} Θ、O、Ω\text{符号）} \\
\infty, & T(n) \text{的增长阶数} > g(n) \text{的增长阶数（} Ω \text{符号）}
\end{cases}
$$

$$
1 < \log n < n < n \log n < n^2 < n^3 < 2^n < 3^n < n! < n^n
$$

**算法的数学分析步骤**：

![](assets/2024-06-23_13-21-33.png)

**非递归算法的数学分析步骤**：

* 确定表示输入大小的参数 $n$
* 确定算法的基本操作
* 检查基本操作的执行次数是否只取决于输入值 $n$ 。如果还取决于输入类型，则分别研究最差、平均和最佳情况下的效率
* 为 $C(n)$ 设置求和，反映算法基本操作的执行次数
* 使用标准公式简化求和，找出封闭式公式，或至少找出其增长顺序

**相关算法**：

* 最大元素问题
* 元素唯一性问题
* 矩阵乘法问题
* 计算二进制数位数问题

**递归算法的数学分析步骤**：

* 确定表示输入大小的参数 $n$
* 确定算法的基本操作
* 检查基本操作的执行次数是否会因相同大小的不同输入而变化，如果会则分别研究最差、平均和最佳情况下的效率
* 为 $C(n)$ 设置递推关系和初始条件，即对大小为 $n$ 的输入执行基本操作的次数（也可计算递推调用次数）
* 通过反向替换法或其他方法解决递推问题或估计解的增长顺序

**相关算法**：

* 递归方式计算阶乘问题
  * 递归条件： $M(n)=M(n-1)+1$
  * 初始条件： $M(0)=0$
  * 反向替换法： $M(n)=n$
* 汉诺塔问题
  * 递归条件： $M(n)=2M(n-1)+1$
  * 初始条件： $M(1)=1$
  * 反向替换法： $M(n)=2^n-1$
* 计算二进制数位数问题
  * 递归条件： $M(n)=M(\lfloor n/2 \rfloor)+1$
  * 初始条件： $M(1)=0$
  * 反向替换法： $M(2^k)=k ⇒ M(n)= \log _2n$
* 斐波那契数列问题
  * 递归条件： $F(n)=F(n-1)+F(n-2)$
  * 初始条件： $F(0)=0$，$F(1)=1$
* 斐波那契螺旋问题

  ![](assets/2024-06-23_13-14-07.png)

* 兔子问题
  * 递归条件： $F(n)=F(n-1)+F(n-2)$
  * 初始条件： $F(0)=1$，$F(1)=1$
* 树枝生长问题（鲁德维格定律）
  一株树苗在一段间隔，例如一年，以后长出一条新枝；第二年新枝“休息”，老枝依旧萌发；此后，老枝与“休息”过一年的枝同时萌发，当年生的新枝则次年“休息”。这样，一株树木各个年份的枝桠数，便构成斐波那契数列。

  ![](assets/2024-06-23_13-15-57.png)

* 上楼梯问题

  ![](assets/2024-06-23_13-18-07.png)

* 蜜蜂进蜂房问题

  ![](assets/2024-06-23_13-19-30.png)

## 03 蛮力法

**相关算法**：

* 计算 $a^n$
* 计算 $n!$
* 连续整数检测算法
* 查找算法
* 矩阵相乘算法

**排序问题**：

* 选择排序
  * 基本操作：比较
  * 比较次数： $n(n-1)/2$
  * 交换次数： $n-1$
  * 该算法不需要考虑最差、平均和最优效率
* 冒泡排序
  * 基本操作：比较
  * 比较次数： $n(n-1)/2$
  * 交换次数： $n(n-1)/2$
  * 对于所有规模为 $n$ 的数组，该算法的键值比较次数相同
  * 最坏的情况是遇到一个降序排列的数组，此时键比较和键交换的次数相同
  * 如果列表中没有交换，则说明列表已经排序，我们可以停止算法

**查找问题**：

* 顺序查找
* 字符串匹配

**蛮力法解决组合问题的步骤**：

* 列出所有解决方案
* 选择满足条件的解决方案
* 逐一评估，排除不可行的解决方案，跟踪找到的最佳解决方案
* 找到的理想解决方案

通过图中所有顶点一次且仅一次的通路称为哈密顿通路。通过图中所有顶点一次且仅一次的回路称为哈密顿回路。具有哈密顿回路的图称为哈密顿图。

**相关算法**：

* 旅行商问题（TSP）：找到最短的哈密顿回路
  * 排列数量： $(n-1)!$
* 背包问题
  * 排列数量： $2^n$
* 任务分配问题
  * 排列数量： $n!$

**NP 难问题**：没有已知的多项式时间解法。
  * 旅行商问题（TSP）
  * 背包问题
  * 任务分配问题

**深度优先搜索（DFS）**：

![](assets/2024-06-23_13-57-09.png)

**广度优先搜索（BFS）**：

![](assets/2024-06-23_13-57-17.png)

## 04 递归法

**递归法**：递归的边界条件和递归方程是递归的两个要点。

递归的简单形式汇掩盖递归的非高效性。

**相关算法**：

* 递归方式计算阶乘

  ![](assets/2024-06-23_14-06-57.png)

* 递归方式计算斐波那契数列

  ![](assets/2024-06-23_14-07-17.png)

  斐波那契数列的一个封闭形式解（Binet 公式）：

  ![](assets/2024-06-23_14-11-46.png)

  ![](assets/2024-06-23_14-17-19.png)

  ![](assets/2024-06-23_14-17-29.png)

* 阿克曼（Ackerman）函数
  * $A(n,0)=n+2$
  * $A(n,1)=2n$
  * $A(n,2)=2^n$

  ![](assets/2024-06-23_14-07-49.png)

* 汉诺塔问题
* 排列问题：先固定第一个元素，求剩下的全排列，求剩下的全排列时，固定剩余元素中的第一个元素，再求剩下元素的全排列，直到就剩一个元素停止
  * 复杂度： $n!$

  ![](assets/2024-06-23_14-21-27.png)

## 05 减治法

**减治法**：自顶向下（递归）与自底向上（迭代）

**减治法的三种变体**：

* 减常量

  ![](assets/2024-06-23_14-25-39.png)

* 减常因子

  ![](assets/2024-06-23_14-26-09.png)

  ![](assets/2024-06-23_14-26-25.png)

* 减可变规模

  ![](assets/2024-06-23_14-26-44.png)

**减一算法**：

* 插入排序：

  ![](assets/2024-06-23_14-32-34.png)

  * 基本操作：比较
  * 最差情况： $n(n-1)/2$
  * 最佳情况： $n-1$
  * 平均情况： $≈n^2/4$

  在使用快速排序时，当子数组小于某个值之后，就可以改用插入排序。

* 拓扑排序：有向无环图（DAG）是拓扑排序的充分必要条件

  * 先修课程问题
    * 深度优先查找（DFS）
      * DFS 遍历注意顶点从堆栈中弹出的顺序
      * 颠倒上述顺序
      * DFS 遍历顺序与拓扑排序顺序相反
      * 复杂度分析：$O(E+V)$ （邻接链表）
    * 基于减治技术（Source Removal Method）
      * 复杂度分析：$O(E+V)$ （邻接链表）

      ![](assets/2024-06-23_14-41-48.png)

  * 生物链问题
  * 程序编译中的指令调度问题
  * 电子表格单元格的公式求值顺序问题
  * 链接器中的符号依赖问题

**减一算法时间效率分析**：

递推方程的一般形式： $T(n)=T(n-1)+f(n)$

$f(n)$ 表示把一个实例化简为一个更小的实例并把更小实例的解拓展为更大实例的解所需要的时间。

使用反向替换法求解，得到：

$$
T(n) = T(0) + \sum_{j=1}^{n} f(j)
$$

**减常因子算法**：

* 二分搜索
  * 最差情况： $\log _2n+1$
  * 最佳情况： $1$
  * 平均情况： $\log _2(n+1)-1$
* 假硬币问题
  * 二分方式
    * 递归条件： $W(n)=W(\lfloor n/2 \rfloor)+1$
    * 初始条件： $W(1)=0$
    * 时间复杂度： $W(n)=O(\log _2n)$
  * 三分方式
    * 递归条件： $W(n)=W(\lfloor n/3 \rfloor)+1$
    * 初始条件： $W(1)=0$
    * 时间复杂度： $W(n)=O(\log _3n)$
* 俄氏乘法

  ![](assets/2024-06-23_14-53-57.png)

  使用俄氏乘法计算 $50 \times 65$ ：

  ![](assets/2024-06-23_14-54-39.png)

**减常因子算法时间效率分析**：

递推方程的一般形式： $T(n)=T(n/b)+f(n)$ （ $b>1$ ）

$f(n)$ 表示把一个实例化简为一个更小的实例并把更小实例的解拓展为更大实例的解所需要的时间。

基于平滑法则，使用反向替换法求解，得到：

$$
T(b^k) = T(1) + \sum_{j=1}^{k} f(b^j)
$$

## 06 分治法

**分治法步骤**：

* 将问题分成两个或多个更小的子问题
* 通过递归解法解决子问题
* 将子问题的解决方案合并为原始问题的解决方案

**合并排序**：按照元素的位置进行划分

![](assets/2024-06-23_15-32-02.png)

* 关键操作：比较
* 递推关系式：
  * 递推条件： $C(n)=2C(n/2)+C_{merge}(n)$
  * 初始条件： $C(1)=0$
* 最坏情况： $C_{merge}(n)=n-1$
* 递推关系式（最坏情况）：
  * 递推条件： $C(n)=2C(n/2)+n-1$
  * 初始条件： $C(1)=0$
* 时间复杂度： $C_{worst}(n)=Θ(n \log n)$

**通用递推关系式**：

* 假设 $n$ 是 $b$ 的幂次，那么大小为 $n$ 的实例可以被分成大小为 $n/b$ 的实例，其中， $a$ 是需要解决的问题的数量
* 运行时间 $T(n)$ 的递推规律如下：

$$
T(n)=aT(n/b)+f(n)
$$

  其中， $f(n)$ 是一个函数，用于计算将问题分割成更小的问题并梳理其解决方案所花费的时间。

**主定理**：

得到通用递推关系式 $T(n)=aT(n/b)+f(n)$ 后，可利用主定理直接求增长次数（仅仅得到增长次数，乘法常量未知；利用初始条件，解递推关系可得精确解）

![](assets/2024-06-23_15-45-15.png)

合并排序的递推关系式： $T(n)=2T(n/2)+n-1$

**二分查找**：

![](assets/2024-06-23_15-55-59.png)

**快速排序**：基于划分（按照元素的值）的排序方法

* 基本操作：比较（根据分区是否平衡）
* 分区的比较次数：
  * 指针交叉： $n+1$
  * 指针相等： $n$
* 最佳情况：所有分裂点位于子数组的中点
  * 递推关系： $C_{best}(n)=2C_{best}(n/2)+n$
  * 初始条件： $C_{best}(1)=0$
  * 利用主定理，可得： $C_{best}(n)∈Θ(n \log n)$
* 最差情况：所有分裂点趋于极端，两个子数组一个为空，另一个仅仅比被划分的数组少一个元素
  * 比较次数： $C_{worst}=(n+1)+n+ \dots + 3=(n+1)(n+2)/2-3∈Θ(n^2)$
* 平均情况：分裂点出现在任意位置，左右数组大小分别为 $s$ 和 $n-1-s$ ，分裂点位于每个位置的概率为 $1/n$
  * 比较次数：

    ![](assets/2024-06-23_16-23-04.png)

    $C_{avg}(n)≈2n \ln n≈1.39n \log n∈O(n \log n)$

![](assets/2024-06-23_16-34-42.png)

快速排序在平均情况下，比较操作只比最佳情况多 $39 \%$ ，而且其最内层循环效率高，在处理随机数组时速度比合并排序快。

**算法特性**：

![](assets/2024-06-23_16-35-43.png)

**基准数优化**：

快速排序在某些输入下的时间效率可能降低。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 $n-1$ 、右子数组长度为 $0$ 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 $0$ ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。

为了尽量避免这种情况发生，我们可以优化哨兵划分中的基准数的选取策略。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。

需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。

为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），并将这三个候选元素的中位数作为基准数。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 $O(n^2)$ 的概率大大降低。

**大整数乘法（第一个分治算法）**：

* 大整数乘法思路：
  * 先将大整数进行分解

    ![](assets/2024-06-23_17-06-43.png)

    例如：

    ![](assets/2024-06-23_17-06-50.png)

  * 然后再求分解式的乘积

    ![](assets/2024-06-23_17-09-18.png)
* 基本操作：一位整数乘法
* 递推关系式：

  ![](assets/2024-06-23_17-11-10.png)

* 根据主定理，得到： $T(n)=O(n^2)$ （没有提升）

**大整数乘法（第二个分治算法）**：将乘法次数从 $4$ 次减少到 $3$ 次

* $X \times Y = ac \cdot 10^n + (ad + bc) 10^{\lfloor n/2 \rfloor} + bd$
* 因为 $(a + b)(c + d)=ac + (ad + bc) + bd$
* 所以 $X \times Y = ac \cdot 10^n + ((a + b)(c + d) - ac - bd) 10^{\lfloor n/2 \rfloor} + bd$

只需进行 $3$ 次乘法运算，但需要 $3$ 次额外的加法 / 减法运算。

* 递推关系式与复杂度（通过主定理）：

  ![](assets/2024-06-23_17-27-58.png)

**蛮力法解决矩阵乘法**：

![](assets/2024-06-23_17-36-51.png)

**斯特拉森（Strassen）矩阵乘法**：

![](assets/2024-06-23_17-39-33.png)

![](assets/2024-06-23_17-39-41.png)

* 递推关系式与复杂度（通过主定理）：

  ![](assets/2024-06-23_17-40-37.png)

* 如果 $n$ 不是 $2$ 的幂，矩阵可以填充零。
* 斯特拉森（Strassen）矩阵乘法的实际应用通常会在矩阵大小小于某个“交叉点”后切换到蛮力法。

**棋盘覆盖问题**：

![](assets/2024-06-23_17-45-19.png)

![](assets/2024-06-23_17-45-58.png)

![](assets/2024-06-23_17-46-47.png)

![](assets/2024-06-23_17-47-26.png)

第一次分割：

![](assets/2024-06-23_17-48-05.png)

第二次分割：

![](assets/2024-06-23_17-48-21.png)

第三次分割：

![](assets/2024-06-23_17-48-45.png)

第四次分割：分割为 $1 \times 1$ 棋盘

![](assets/2024-06-23_17-50-22.png)

复杂度分析：

![](assets/2024-06-23_17-52-01.png)

渐进意义下的最优算法： $T(n)=O(4^k)$

所需骨牌个数： $(4^k-1)/3$

**思考题一**：

> 设 `a[0, n-1]` 是一个已经排好序的数组。设计一个搜索算法，使得当搜索元素 `x` 在数组中时， `i` 和 `j` 相同，均为 `x` 在数组中的位置；当搜索元素 `x` 不在数组中时，返回小于 `x` 的最大元素的位置 `i` 和大于 `x` 的最小元素位置 `j` 。

```python
def binary_search_bounds(arr, x):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == x:
            return mid, mid
        elif arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return right, left
```

**思考题二**：

> 给定两个大整数 $u$ 和 $v$ ，分别具有 $m$ 位和 $n$ 位数字，且 $m \leq n$ 。使用常规的乘法算法求解 $uv$ 的乘积需要 $O(mn)$ 的时间复杂度。当 $m$ 明显小于 $n$ 时，设计一个算法，在上述情况下用时间复杂度 $O(nm^{\log _2 1.5})$ 求解 $uv$ 的乘积。

为了解决给定的问题，我们可以借助经典的卡拉楚巴（Karatsuba）算法。卡拉楚巴算法基于分治策略，通过将大数字的乘法问题分解成更小的子问题来降低时间复杂度。标准的卡拉楚巴算法可以将两个 $n$ 位数字的乘法时间复杂度从 $O(n^2)$ 降低到 $O(n^{\log _23}) ≈ O(n^{1.585})$ 。

在这里，我们需要解决的问题是 $u$ 和 $v$ 的位数不同，其中 $u$ 的位数 $m$ 明显小于 $v$ 的位数 $n$。我们可以将 $v$ 分成长度为 $m$ 的多个部分，并使用分治法和卡拉楚巴算法来解决这个问题。具体步骤如下：

1. 将 $v$ 分段：
   将 $v$ 分解为长度约为 $m$ 的若干部分，例如：如果 $v$ 是一个 $n$ 位数，我们可以将其分为 $\lceil n/m \rceil$ 个部分，每部分最多 $m$ 位。具体地，设 $v = v_0 + v_1 \cdot 10^m + v_2 \cdot 10^{2m} + \ldots + v_k \cdot 10^{km}$，其中每个 $v_i$（对于 $i<k$）都是一个 $m$ 位数，而 $v_k$ 可能少于 $m$ 位。
2. 对每个分段使用卡拉楚巴乘法：
   对于每个分段 $v_i$，使用卡拉楚巴算法计算 $u \cdot v_i$。由于 $u$ 和 $v_i$ 都是 $m$ 位数，这个乘法的复杂度是 $O(m^{\log_2 3})$。
3. 合并结果：
   最后，将所有的乘积结果合并，即将 $u \cdot v_i \cdot 10^{im}$ 相加，从 $i = 0$ 到 $k$。

整体时间复杂度的计算如下：

* 有 $\lceil n/m \rceil$ 个部分 $v_i$ 。
* 每个部分乘法的时间复杂度是 $O(m^{\log_2 3})$ 。
* 因此，整体乘法的时间复杂度为 $O((n/m) \cdot m^{\log_2 3}) = O(nm^{\log_2 3 - 1}) = O(nm^{\log_2 1.5}) = O(nm^{0.585})$ 。

## 文档更新日期

2024年6月23日