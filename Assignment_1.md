# Assignment 1

## Question 1

增长速度排序：

$\sqrt{n}$ < $2\lg(n + 50)^5$ < $0.05n^{10} + 3n^3 + 1$ < $3^{2n}$ < $3^{3n}$ < $(n^2 + 3)!$

即：(e) < (b) < (d) < (f) < (c) < (a)

## Question 2

a. 这个算法的用途是计算数组 `A` 中所有大于某个给定值（此处为 $50$ ）的元素之和与所有小于该给定值的元素之和之差。

b. 这个算法的基础运算是比较操作 `A[i] > val` 和 `A[i] < val` 。在大多数情况下，我们选取最内层循环中重复出现次数最多的操作作为基础运算。在这个算法中，尽管比较和加减操作都被执行，但比较操作更为关键，因为它直接决定了加减操作是否会发生。因此，比较操作是基础运算，因为不管后续的加减操作是否执行，比较操作总是会发生的。

c. 基础运算执行的次数取决于数组 `A` 的长度 $n$ 。由于算法包含一个从 $0$ 到 $n-1$ 的循环，且在循环内有两个比较操作，每个元素会进行两次比较，因此基础运算执行了 $2n$ 次。

d. 这个算法的时间复杂度是 $O(n)$ 。由于每个元素进行恒定次数的操作（每个元素进行两次比较），所以算法的执行时间与数组 `A` 的长度 $n$ 成线性关系。

## Question 3

a. 该算法用于检查一个给定的 $n \times n$ 矩阵是否为对称矩阵。

b. 算法的基础运算是比较两个元素 `A[i][j]` 和 `A[j][i]` 是否相等。

c. 这个算法通过双层循环，遍历了矩阵的上三角部分（不包括对角线）。对于第 $i$ 行，内层循环从 $i+1$ 开始，直到 $n−1$ 结束。因此，对于第 $i$ 行，比较操作执行了 $n−i−1$ 次。所以，在最坏情况下，总的比较次数为：

$$
\sum_{i=0}^{n-2}(n-i-1) = \frac{n(n-1)}{2}
$$

d. 时间复杂度基于基础运算的次数来计算。从上面的计算可以看出，基础运算执行次数随着 $n$ 的增长而以平方的速度增长。因此，这个算法的时间复杂度是 $O(n^2)$ 。在最坏情况下，即算法必须遍历整个上三角矩阵来确定矩阵是否对称时，执行的基础运算次数正好是 $\frac{n(n-1)}{2}$ ，这正是 $O(n^2)$ 复杂度的表现。

## Question 4

a. $T(n)=T(n-1)+2,T(1)=1$

对于这个递归式，可以通过直接观察法来求解。它表明每一项比前一项多 $2$ 。

* 当 $n=2$ 时， $T(2)=T(1)+2=1+2=3$
* 当 $n=3$ 时， $T(3)=T(2)+2=3+2=5$

可以看出，随着 $n$ 的增加，每一步都增加 $2$ ，所以有： $T(n)=2n-1$ 。

b. $T(n)=2T(\frac{n}{2})+n,T(1)=1$

使用主定理（Master Theorem）解决递归式 $T(n)=2T(\frac{n}{2})+n,T(1)=1$ 的通项公式，我们首先需要识别递归式与主定理三种情形中的哪一种相匹配。

主定理表述了对于递归式 $T(n)=aT(\frac{n}{b})+f(n)$ （其中 $a\geq1$ 和 $b>1$ 是常数， $f(n)$ 是一个给定的函数），其解的形式依赖于 $f(n)$ 与 $n^{\log_b a}$ 的相对增长率：

* 如果 $f(n) = O(n^{\log_b a - \epsilon})$ 对某个常数 $\epsilon > 0$ 成立，则 $T(n) = \Theta(n^{\log_b a})$ 。
* 如果 $f(n) = \Theta(n^{\log_b a})$，则 $T(n) = \Theta(n^{\log_b a} \log n)$ 。
* 如果 $f(n) = \Omega(n^{\log_b a + \epsilon})$ 对某个常数 $\epsilon > 0$ 成立，并且对于某个常数 $c < 1$ 和所有足够大的 $n$ ，有 $af(\frac{n}{b}) \leq cf(n)$ ，则 $T(n) = \Theta(f(n))$ 。

对于给定的递归式 $T(n)=2T(\frac{n}{2})+n$ ，我们可以看出 $a=2$ ， $b=2$ ，和 $f(n)=n$ 。计算 $\log_b a$ 得到 $\log_2 2=1$ 。这里 $f(n)=n=n^{1}=n^{\log_2 2}$ ，说明我们处于主定理的第二种情况。

根据主定理的第二种情况，我们得到通项公式：

$$
T(n) = \Theta\left(n^{\log_b a} \log n\right) = \Theta(n \log n)
$$

因此，对于给定的递归式 $T(n)=2T(\frac{n}{2})+n,T(1)=1$ ，其通项公式为 $T(n) = \Theta(n \log n)$ 。

c. $T(n)=T(n-1)+n^2,T(1)=1$

这个递归式可以通过展开来解决：

* 当 $n=2$ 时， $T(2)=T(1)+2^2=1+4=5$
* 当 $n=3$ 时， $T(3)=T(2)+3^2=5+9=14$

展开这个递归式，我们得到： $T(n)=1+2^2+3^2+\cdots+n^2$ 。

已知 $1+2^2+3^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}$ 。这个公式的推导可以通过数学归纳法完成。

1. 基础步骤

   首先，我们验证 $n=1$ 时该公式是否成立。将 $n=1$ 代入公式， $T(1)=1$ ，公式成立。

2. 归纳步骤

   假设对于某个正整数 $k$ ，该公式成立，即

$$
T(k)=1+2^2+3^2+\cdots+k^2=\frac{k(k+1)(2k+1)}{6}
$$

   我们需要证明当 $n=k+1$ 时，该公式仍然成立。

$$
T(k+1)=\frac{k(k+1)(2k+1)}{6}+(k+1)^2=\frac{(k+1)(k+2)(2k+3)}{6}
$$

   所以我们证明了当 $n=k+1$ 时，公式也成立。

通过基础步骤和归纳步骤，我们证明了对所有正整数 $n$ ，求和公式

$$
T(n)=1+2^2+3^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}
$$

成立。这就完成了数学归纳法的证明过程。

## Question 5

这是一个典型的斐波那契数列问题，其递推公式基于兔子繁殖的模式。具体来说，每一对兔子从出生后的第二个月开始，每月都能生下一对新的兔子。这意味着在任何给定的月份，兔子的总对数都是前两个月兔子对数的和，因为新生的兔子对还不能繁殖，而前一个月的所有兔子对在这个月都会繁殖。

定义 $T(n)$ 为第 $n$ 个月末的兔子对数，其递推公式为：

$$
T(n)=T(n-1)+T(n-2)
$$

其中 $T(1)=1$ 和 $T(2)=1$ ，因为在第一个月和第二个月末，只有最初放置的那一对兔子。

为了找出一年后（即第 $12$ 个月末）的兔子对数，我们可以使用上述递推公式来计算 $T(12)$ 的值。即 $T(12)=144$ 。

## Question 6

### Solution

这个问题是一个典型的博弈问题，可以通过递归方法解决。主要思想是考虑每个玩家在每一步可以做出的最优选择，并预测对手的最优响应。我们利用递归函数 `maxScore` 来计算从数组的 `i` 位置到 `j` 位置，当前玩家可以获得的最大分数差。 `turn` 参数用于表示当前轮到哪个玩家，其中 `1` 表示玩家1， `-1` 表示玩家2。这种方法通过每次递归调用都翻转 `turn` 的符号，模拟双方轮流进行选择的过程。

解题思路：

* 递归基础：当 `i` 等于 `j` 时，数组中只剩下一个元素，那么当前玩家只能选择这个元素，得分为 `turn * nums[i]` 。
* 记忆化递归：使用一个二维数组 `memo` 来存储当前玩家可以获得的最大分数差，以避免递归过程中的重复计算。
* 递归逻辑：
  * 对于当前玩家，有两种选择：选择 `i` 位置的元素或选择 `j` 位置的元素。
  * 如果选择了 `i` 位置的元素，则下一个玩家将面对从 `i + 1` 到 `j` 的数组；相似地，如果选择了 `j` 位置的元素，则下一个玩家将面对从 `i` 到 `j - 1` 的数组。
  * 计算这两种选择后当前玩家可能获得的最大分数差，并选择最优的一种。
* 最终判断：如果在整个数组范围内，玩家1可以获得的最大分数差大于或等于 `0` ，则玩家1可以保证获胜或者同分，函数返回 `true` ；否则，返回 `false` 。

### Code

```cpp
#include <iostream>
#include <vector>

class Solution {
private:
    std::vector<std::vector<int>> memo;

    int maxScore(std::vector<int>& nums, int i, int j, int turn) {
        if (i == j) {
            return turn * nums[i];
        }
        if (memo[i][j] != INT_MIN) {
            return memo[i][j];
        }
        int leftScore = turn * nums[i] + maxScore(nums, i + 1, j, -turn);
        int rightScore = turn * nums[j] + maxScore(nums, i, j - 1, -turn);
        memo[i][j] = std::max(leftScore * turn, rightScore * turn) * turn;
        return memo[i][j];
    }

public:
    bool predictTheWinner(std::vector<int>& nums) {
        int n = static_cast<int>(nums.size());
        memo.assign(n, std::vector<int>(n, INT_MIN));
        return maxScore(nums, 0, n - 1, 1) >= 0;
    }
};

int main()
{
    Solution solution;
    std::cout << std::boolalpha;

    // Test Case 1
    std::vector<int> testCase1 = { 1,5,2 };
    std::cout << solution.predictTheWinner(testCase1) << std::endl;

    // Test Case 2
    std::vector<int> testCase2 = { 7,10,6,8 };
    std::cout << solution.predictTheWinner(testCase2) << std::endl;

    // Test Case 3
    std::vector<int> testCase3 = { 1,3,2,1,2,3,2,3,1 };
    std::cout << solution.predictTheWinner(testCase3) << std::endl;

    return 0;
}
```